# Q 0 : # @comment.group.message_channel
Query(Group)
.where("id = ?")
# Q 1 : # @discussion.first_sequence_id
Query(Discussion)
.select('first_sequence_id')
# Q 2 : # @discussion.items.distinct.includes(:user, :discussion, :eventable, parent: [:user, :eventable])
Query(Event)
.where("discussion_id = ?")
.distinct('')
.includes('user')
# Q 3 : # @discussion.last_sequence_id
Query(Discussion)
.select('last_sequence_id')
# Q 4 : # @events.select { |event|
#   
#   event.kind == "new_comment"
# }.map(&:eventable_id)
Query(Event)

# Q 5 : # @group.add_admin!(patrick).set_volume!(:loud)
Query(Group)

# Q 6 : # @group.add_admin!(patrick).set_volume!(:loud)
Query(Group)

# Q 7 : # @group.admin_memberships.each
Query(Membership)
.where("group_id = ?")
# Q 8 : # @group.discussions.create!(title: "This thread is private", private: true, author: jennifer)
Query(Discussion)
.where("group_id = ?")
# Q 9 : # @group.discussions.create!(title: "This thread is public", private: false, author: jennifer)
Query(Discussion)
.where("group_id = ?")
# Q 10 : # @group.membership_requests.pending.where(requestor_id: user.id)
Query(MembershipRequest)
.where("group_id = ?")
.where("requestor_id = ?")
# Q 11 : # @user.admin_memberships.find_by(group: groups)
Query(User)
.where("group = ?")
# Q 12 : # @user.admin_memberships.find_by(group_id: group_id)
Query(User)
.where("group_id = ?")
# Q 13 : # @user.formal_groups.visible_to_public.pluck(:id)
Query(User)
.select('id')
# Q 14 : # @user.memberships.find_by(group: groups)
Query(User)
.where("group = ?")
# Q 15 : # @user.memberships.find_by(group_id: group_id)
Query(User)
.where("group_id = ?")
# Q 16 : # Comment.find(event_comment_ids).map { |c|
#   
#   [c.id, c.mentioned_usernames]
# }.to_h
Query(Comment)
.where("id = ?")
# Q 17 : # Comment.select("LEFT(string_agg(body, ','), 20000) AS comment_bodies").where(discussion_id: self.discussion_id)
Query(Comment)
.select('LEFT(string_agg(body, ','), 20000) AS comment_bodies')
.where("discussion_id = ?")
# Q 18 : # Comment.where(id: forked_items.where(kind: :new_comment).pluck(:eventable_id))
Query(Comment)
.where("id = ?")
# Q 19 : # Discussion.find_by(guest_group_id: id)
Query(Discussion)
.where("guest_group_id = ?")
# Q 20 : # DiscussionReader.joins(:user).where(discussion: @discussion).where.not(last_read_at: nil).map
Query(DiscussionReader)
.joins('user')
.where("discussion = ?")
.where("last_read_at = ?")
# Q 21 : # DiscussionTag.joins(:tag).where(discussion: discussions).group_by(&:discussion_id)
Query(DiscussionTag)
.joins('tag')
.where("discussion = ?")
# Q 22 : # Document.where(group_id: group_ids)
Query(Document)
.where("group_id = ?")
# Q 23 : # Document.where(model_type: "Comment", model_id: event_comment_ids).group_by(&:model_id)
Query(Document)
.where("model_type = ?")
.where("model_id = ?")
# Q 24 : # Event.find(params[:id])
Query(Event)
.where("id = ?")
# Q 25 : # Event.find(params[:id])
Query(Event)
.where("id = ?")
# Q 26 : # Event.find_by!(discussion: @discussion, depth: 1, position: position)
Query(Event)
.where("discussion = ?")
.where("depth = ?")
.where("position = ?")
# Q 27 : # Event.find_by!(discussion: @discussion, depth: 1, position: position).sequence_id
Query(Event)
.where("discussion = ?")
.where("depth = ?")
.where("position = ?")
# Q 28 : # Event.find_by!(kind: "new_comment", eventable_type: "Comment", eventable_id: params[:comment_id])
Query(Event)
.where("kind = ?")
.where("eventable_type = ?")
.where("eventable_id = ?")
# Q 29 : # Event.find_by!(kind: "new_comment", eventable_type: "Comment", eventable_id: params[:comment_id]).sequence_id
Query(Event)
.where("kind = ?")
.where("eventable_type = ?")
.where("eventable_id = ?")
# Q 30 : # Event.where(id: @events.map(&:id)).includes(:eventable)
Query(Event)
.where("id = ?")
# Q 31 : # Event.where(id: discussion.forked_event_ids).pluck(:discussion_id).uniq.length
Query(Event)
.where("id = ?")
.select('discussion_id')
.distinct('')
# Q 32 : # Event.where(id: self.forked_event_ids).order(:sequence_id)
Query(Event)
.where("id = ?")
.order('sequence_id')
# Q 33 : # Event.where(kind: ["announcement_created", "user_mentioned", "announcement_resend"], eventable: history_model).order("id").limit(50)
Query(Event)
.where("kind = ?")
.where("eventable = ?")
.order('id')
.return_limit('')
# Q 34 : # FormalGroup.where(id: id_and_subgroup_ids).sum(:discussions_count)
Query(FormalGroup)
.where("id = ?")
# Q 35 : # Group.find(params[:group_id]).parent_or_self.id_and_subgroup_ids
Query(Group)
.where("id = ?")
# Q 36 : # Group.find_by!(handle: request.subdomain)
Query(Group)
.where("handle = ?")
# Q 37 : # Group.find_by(token: session[:pending_group_token])
Query(Group)
.where("token = ?")
# Q 38 : # Group.order("memberships_count desc").first
Query(Group)
.order('id, memberships_count')
.return_limit('1')
# Q 39 : # Group.published.where(id: ids).or(Group.published.where("parent_id in (:ids)", ids: ids).where("is_visible_to_parent_members = true or is_visible_to_public = true"))
Query(Group)
.where("id = ?")
# Q 40 : # Group.where(id: former_group_ids).map(&:update_memberships_count)
Query(Group)
.where("id = ?")
# Q 41 : # Group.where(subscription_id: self.id).map(&:org_members_count).sum
Query(Group)
.where("subscription_id = ?")
# Q 42 : # LoginToken.find_by!(token: params[:token])
Query(LoginToken)
.where("token = ?")
# Q 43 : # LoginToken.find_by(token: session[:pending_login_token])
Query(LoginToken)
.where("token = ?")
# Q 44 : # LoginToken.unused.find_by(code: resource_params.require(:code))
Query(LoginToken)
.where("code = ?")
# Q 45 : # Membership.active.joins(:user).where("users.email" => email, :group_id => group.id).exists?
Query(Membership)
.where("email" = ?")
.where("group_id = ?")
.return_limit('1')
# Q 46 : # Membership.find(custom_fields["membership_id"])
Query(Membership)
.where("id = ?")
# Q 47 : # Membership.find_by!(token: params[:token])
Query(Membership)
.where("token = ?")
# Q 48 : # Membership.find_by(group: @muted_group, user: patrick)
Query(Membership)
.where("group = ?")
.where("user = ?")
# Q 49 : # Membership.find_by(user: patrick, group: @group)
Query(Membership)
.where("user = ?")
.where("group = ?")
# Q 50 : # Membership.find_by(user: patrick, group: @group)
Query(Membership)
.where("user = ?")
.where("group = ?")
# Q 51 : # Membership.find_by(user: patrick, group: @group)
Query(Membership)
.where("user = ?")
.where("group = ?")
# Q 52 : # Membership.find_by(user: patrick, group: @group)
Query(Membership)
.where("user = ?")
.where("group = ?")
# Q 53 : # Membership.find_by(user_id: patrick.id, group_id: another_group.id)
Query(Membership)
.where("user_id = ?")
.where("group_id = ?")
# Q 54 : # Membership.joins(:group).where(group_id: same_group_ids + public_group_ids, user_id: @user.id).active.formal.order("groups.full_name")
Query(Membership)
.where("group_id = ?")
.where("user_id = ?")
.order('id, full_name')
# Q 55 : # Membership.not_archived.where(user_id: user.id, group_id: group.id).first
Query(Membership)
.where("user_id = ?")
.where("group_id = ?")
.return_limit('1')
# Q 56 : # Membership.pending.find_by(token: pending_membership_token)
Query(Membership)
.where("token = ?")
# Q 57 : # Membership.pending.where(id: event.custom_fields["membership_ids"]).pluck(:id)
Query(Membership)
.where("id = ?")
.select('id')
# Q 58 : # Membership.where(id: custom_fields["membership_ids"])
Query(Membership)
.where("id = ?")
# Q 59 : # Notification.includes(:user).where(event_id: events.pluck(:id)).order("users.name, users.email").each
Query(Notification)
.includes('user')
.where("event_id = ?")
.order('id, name, email')
# Q 60 : # Notification.where(event_id: all_events.pluck(:id))
Query(Notification)
.where("event_id = ?")
# Q 61 : # Poll.find_by(guest_group_id: id)
Query(Poll)
.where("guest_group_id = ?")
# Q 62 : # Poll.select("string_agg(title, ',')                AS poll_titles").select("LEFT(string_agg(details, ','), 10000) AS poll_details").where(discussion_id: self.discussion_id)
Query(Poll)
.select('string_agg(title, ',')                AS poll_titles')
.select('LEFT(string_agg(details, ','), 10000) AS poll_details')
.where("discussion_id = ?")
# Q 63 : # SamlProvider.find(params[:id])
Query(SamlProvider)
.where("id = ?")
# Q 64 : # SamlProvider.find_by!(group_id: find_group!.id)
Query(SamlProvider)
.where("group_id = ?")
# Q 65 : # SamlProvider.find_by!(group_id: params[:group_id])
Query(SamlProvider)
.where("group_id = ?")
# Q 66 : # SamlProvider.find_by!(group_id: session[:saml_group_id])
Query(SamlProvider)
.where("group_id = ?")
# Q 67 : # SamlProvider.find_by(group_id: group.id)
Query(SamlProvider)
.where("group_id = ?")
# Q 68 : # SamlProvider.where(group: group).destroy_all
Query(SamlProvider)
.where("group = ?")
# Q 69 : # User.active.find_by!(email: email)
Query(User)
.where("email = ?")
# Q 70 : # User.active.find_by!(id: params[:source_id])
Query(User)
.where("id = ?")
# Q 71 : # User.active.find_by!(id: params[:source_id])
Query(User)
.where("id = ?")
# Q 72 : # User.active.find_by!(id: params[:target_id])
Query(User)
.where("id = ?")
# Q 73 : # User.active.find_by!(id: params[:target_id])
Query(User)
.where("id = ?")
# Q 74 : # User.active.verified.find_by(email: eventable.participant.email)
Query(User)
.where("email = ?")
# Q 75 : # User.active.where(id: Membership.where(id: custom_fields["membership_ids"]).pluck(:user_id))
Query(User)
.where("id = ?")
# Q 76 : # User.active.where(id: memberships.pluck(:user_id))
Query(User)
.where("id = ?")
# Q 77 : # User.find_by(email: "emilio@loomio.org")
Query(User)
.where("email = ?")
# Q 78 : # User.find_by(email: "jennifer_grey@example.com")
Query(User)
.where("email = ?")
# Q 79 : # User.find_by(email: "judd@example.com")
Query(User)
.where("email = ?")
# Q 80 : # User.find_by(email: "max@example.com")
Query(User)
.where("email = ?")
# Q 81 : # User.find_by(email: "patrick_swayze@example.com")
Query(User)
.where("email = ?")
# Q 82 : # User.find_by(email: "rudd@example.com")
Query(User)
.where("email = ?")
# Q 83 : # User.find_by(email: sign_up_params[:email], email_verified: false)
Query(User)
.where("email = ?")
.where("email_verified = ?")
# Q 84 : # User.find_by(id: session[:pending_user_id])
Query(User)
.where("id = ?")
# Q 85 : # User.find_by_unsubscribe_token(params[:unsubscribe_token])
Query(User)
.where("unsubscribe_token = ?")
# Q 86 : # User.verified.find_by(email: identity.email)
Query(User)
.where("email = ?")
# Q 87 : # User.verified.find_by(email: super.email)
Query(User)
.where("email = ?")
# Q 88 : # User.verified_first.find_by!(email: params.require(:email))
Query(User)
.where("email = ?")
# Q 89 : # User.where("time_zone is not null").joins(:memberships).where(:"memberships.group_id" => user.formal_group_ids).group(:time_zone).count.sort_by
Query(User)
.group('time_zone')
# Q 90 : # User.where(email: params[:email]).any?
Query(User)
.where("email = ?")
# Q 91 : # User.where(email: resource_params[:email]).where.not(locked_at: nil).exists?
Query(User)
.where("email = ?")
.where("locked_at = ?")
.return_limit('1')
# Q 92 : # User.where(id: all_reactions.pluck(:user_id))
Query(User)
.where("id = ?")
# Q 93 : # User.where(id: custom_fields["reminded_user_id"].to_i)
Query(User)
.where("id = ?")
# Q 94 : # User.where(id: custom_fields["user_ids"])
Query(User)
.where("id = ?")
# Q 95 : # User.where(id: eventable.author_id)
Query(User)
.where("id = ?")
# Q 96 : # User.where(id: eventable.inviter_id)
Query(User)
.where("id = ?")
# Q 97 : # User.where(id: eventable.parent.author_id)
Query(User)
.where("id = ?")
# Q 98 : # User.where(id: eventable.user_id)
Query(User)
.where("id = ?")
# Q 99 : # User.where(id: eventable.user_id)
Query(User)
.where("id = ?")
# Q 100 : # User.where(id: eventable.user_id)
Query(User)
.where("id = ?")
# Q 101 : # User.where(id: membership.user_id)
Query(User)
.where("id = ?")
# Q 102 : # User.where(id: poll.author_id).where.not(id: eventable.participant)
Query(User)
.where("id = ?")
.where("id = ?")
# Q 103 : # User.where(id: reactable.author_id)
Query(User)
.where("id = ?")
# Q 104 : # User.where(id: self.notifications.user_mentions.pluck(:user_id))
Query(User)
.where("id = ?")
# Q 105 : # User.where(username: parent.author.username)
Query(User)
.where("username = ?")
# Q 106 : # active.distinct.where(closing_at: timeframe).where("NOT EXISTS (SELECT 1 FROM events
#                 WHERE events.created_at     > ? AND
#                       events.eventable_id   = polls.id AND
#                       events.eventable_type = 'Poll' AND
#                       events.kind           = 'poll_closing_soon')", recency_threshold)
Query(Poll)
.distinct('')
.where("closing_at = ?")
# Q 107 : # active.verified.where(email_catch_up: true)
Query(User)
.where("email_catch_up = ?")
# Q 108 : # active.where("polls.closing_at < ?", Time.now)
Query(Poll)

# Q 109 : # active.where(email_when_proposal_closing_soon: true)
Query(User)
.where("email_when_proposal_closing_soon = ?")
# Q 110 : # comment.group
Query(Group)
.where("id = ?")
# Q 111 : # user.contacts.pluck(:email)
Query(user)
.select('email')
# Q 112 : # user.formal_groups.pluck(:id)
Query(user)
.select('id')
# Q 113 : # discussion.comments.last
Query(Comment)
.where("discussion_id = ?")
.return_limit('1')
# Q 114 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 115 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 116 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 117 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 118 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 119 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 120 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 121 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 122 : # discussion.group
Query(FormalGroup)
.where("id = ?")
# Q 123 : # discussion.group.admins.first
Query(Group)
.where("id = ?")
.where("formal_group_id = ?")
.return_limit('1')
# Q 124 : # discussion.group.admins.first
Query(Group)
.where("id = ?")
.where("formal_group_id = ?")
.return_limit('1')
# Q 125 : # discussion.group.admins.first
Query(Group)
.where("id = ?")
.where("formal_group_id = ?")
.return_limit('1')
# Q 126 : # discussion.group.admins.first
Query(Group)
.where("id = ?")
.where("formal_group_id = ?")
.return_limit('1')
# Q 127 : # discussion.group.admins.first
Query(Group)
.where("id = ?")
.where("formal_group_id = ?")
.return_limit('1')
# Q 128 : # discussion.group.admins.first
Query(Group)
.where("id = ?")
.where("formal_group_id = ?")
.return_limit('1')
# Q 129 : # discussion.group.archived_at
Query(FormalGroup)
.where("id = ?")
.select('archived_at')
# Q 130 : # discussion.group.members_can_announce?
Query(FormalGroup)
.where("id = ?")
# Q 131 : # discussion.group.members_can_edit_discussions?
Query(FormalGroup)
.where("id = ?")
# Q 132 : # discussion.group.members_can_start_discussions?
Query(FormalGroup)
.where("id = ?")
# Q 133 : # discussion.group.membership_for(user)
Query(FormalGroup)
.where("id = ?")
# Q 134 : # discussion.group.parent_members_can_see_discussions?
Query(FormalGroup)
.where("id = ?")
# Q 135 : # discussion.group.present?
Query(FormalGroup)
.where("id = ?")
# Q 136 : # discussion.guest_group.memberships.find_by(token: user.membership_token)
Query(Discussion)
.where("token = ?")
# Q 137 : # discussion.guest_group.memberships.find_by(user: recipient)
Query(Discussion)
.where("user = ?")
# Q 138 : # discussion.items.order(:sequence_id).last.created_at
Query(Event)
.where("discussion_id = ?")
.order('sequence_id')
.return_limit('1')
# Q 139 : # discussion.items.order(:sequence_id).pluck(:sequence_id)
Query(Event)
.where("discussion_id = ?")
.order('sequence_id')
.select('sequence_id')
# Q 140 : # discussion.items.order(sequence_id: :asc).limit(5).pluck(:sequence_id)
Query(Event)
.where("discussion_id = ?")
.order('sequence_id')
.return_limit('')
.select('sequence_id')
# Q 141 : # discussion.items.order(sequence_id: :asc).pluck(:sequence_id)
Query(Event)
.where("discussion_id = ?")
.order('sequence_id')
.select('sequence_id')
# Q 142 : # discussion.items.order(sequence_id: :desc).limit(5).pluck(:sequence_id)
Query(Event)
.where("discussion_id = ?")
.order('sequence_id')
.return_limit('')
.select('sequence_id')
# Q 143 : # distinct.active.search_for(query).joins(:memberships).where(:"memberships.group_id" => group_ids).where.not(:"users.id" => user.id).order("users.name")
Query(User)
.order('id, name')
# Q 144 : # distinct.active.verified.joins(:memberships).where(:"memberships.group_id" => user.group_ids).where.not(id: user.id)
Query(User)
.where("id = ?")
# Q 145 : # document.model.group.id
Query(Document)
.where("id = ?")
.group('')
# Q 146 : # documents.pluck(:author_id).select { |user_id|
#   
#   user_id != user.id
# }.empty?
Query(Document)
.select('author_id')
# Q 147 : # event.notifications.where(user: user).update_all(viewed: true)
Query(Event)
.where("user = ?")
# Q 148 : # events.find_by(kind: :discussion_forked)
Query(Event)
.where("kind = ?")
# Q 149 : # events.find_by(kind: created_event_kind)
Query(Event)
.where("kind = ?")
# Q 150 : # group.admins.first
Query(Group)
.where("group_id = ?")
.return_limit('1')
# Q 151 : # group.admins.first
Query(Group)
.where("group_id = ?")
.return_limit('1')
# Q 152 : # group.archived_at
Query(Group)
.select('archived_at')
# Q 153 : # group.archived_at
Query(Group)
.select('archived_at')
# Q 154 : # group.creator
Query(User)
.where("id = ?")
# Q 155 : # group.discussions.create!(title: "This thread is public", private: false, author: patrick)
Query(Discussion)
.where("group_id = ?")
# Q 156 : # group.discussions.create!(title: "This thread is public", private: false, author: patrick)
Query(Discussion)
.where("group_id = ?")
# Q 157 : # group.key
Query(Group)
.select('key')
# Q 158 : # group.members_can_raise_motions
Query(Group)
.select('members_can_raise_motions')
# Q 159 : # group.members_can_vote
Query(Group)
.select('members_can_vote')
# Q 160 : # group.memberships.update_all(saml_session_expires_at: Time.current)
Query(Membership)
.where("group_id = ?")
# Q 161 : # group.memberships.update_all(saml_session_expires_at: nil)
Query(Membership)
.where("group_id = ?")
# Q 162 : # group.parent.members.where(:"users.id" => params[:user_ids])
Query(Group)
.where("id = ?")
.where("group_id = ?")
# Q 163 : # group.parent.members_can_create_subgroups?
Query(Group)
.where("id = ?")
# Q 164 : # group_ids = (
# model.group.parent_or_self.id_and_subgroup_ids + [model.guest_group.id]).compact.uniq
Query(User)
.where("id != 0")
.distinct('')
# Q 165 : # guest_group.members.where.not(id: group.presence.member_ids)
Query(Group)
.where("guest_group_id = ?")
.where("id = ?")
# Q 166 : # includes(:documents, :poll_options, :outcomes, { stances: [:stance_choices] })
Query(Poll)
.includes('documents')
.includes('poll_options')
.includes('outcomes')
# Q 167 : # joins("INNER JOIN users ON users.id = discussions.author_id").where("discussions.title ilike :fragment OR users.name ilike :fragment", fragment: "%#{
# fragment}%")
Query(Discussion)

# Q 168 : # joins("LEFT OUTER JOIN discussion_readers dr ON (dr.user_id = users.id AND dr.discussion_id = #{
# model.discussion_id.to_i})")
Query(User)

# Q 169 : # joins("LEFT OUTER JOIN memberships fm ON (fm.user_id = users.id AND fm.group_id = #{
# model.group_id.to_i})").where(:"fm.archived_at" => nil)
Query(User)

# Q 170 : # joins("LEFT OUTER JOIN memberships gm ON (gm.user_id = users.id AND gm.group_id = #{
# model.guest_group_id.to_i})").where(:"gm.archived_at" => nil)
Query(User)

# Q 171 : # joins(:memberships).where("memberships.admin = ?", true).group("users.id")
Query(User)
.group('id')
# Q 172 : # joins(:poll_options).order("poll_options.priority ASC")
Query(Stance)
.joins('poll_options')
.order('id, priority')
# Q 173 : # joins(:poll_options).order("poll_options.priority DESC")
Query(Stance)
.joins('poll_options')
.order('id, priority')
# Q 174 : # joins(:stance).order("CASE coalesce(stances.reason, '') WHEN '' THEN 1 ELSE 0 END").order(:created_at)
Query(StanceChoice)
.joins('stance')
.order('id, reason')
.order('created_at')
# Q 175 : # joins(:user).joins("LEFT OUTER JOIN stances ON stances.participant_id = users.id AND stances.poll_id = #{
# poll.id}").where(group: [poll.group, poll.discussion_guest_group, poll.guest_group]).where(:"stances.id" => nil).accepted
Query(InvitationAlreadyUsed)
.where("group = ?")
# Q 176 : # joins(discussion: :group).select(:discussion_id, :search_vector, "groups.name as result_group_name", "groups.id as result_group_id").select("ts_rank_cd('{#{
# WEIGHT_VALUES.join(",")}}', search_vector, plainto_tsquery(#{
# query})) * #{
# recency_multiplier} as rank").where("search_vector @@ plainto_tsquery(#{
# query})").order("rank DESC")
Query(SearchVector)
.select('groups.name as result_group_namegroups.id as result_group_id')
.select('ts_rank_cd('{? }', search_vector, plainto_tsquery(? )) * ?  as rank')
.order('id, rank')
# Q 177 : # membership.group.admin_memberships.count
Query(Membership)
.group('')
# Q 178 : # membership_request.group
Query(Group)
.where("id = ?")
# Q 179 : # membership_requests.where("responded_at IS NULL").destroy_all
Query(MembershipRequest)

# Q 180 : # memberships.find_by(group_id: group.id)
Query(Membership)
.where("group_id = ?")
# Q 181 : # memberships.find_by(group_id: group.id, admin: true)
Query(Membership)
.where("group_id = ?")
.where("admin = ?")
# Q 182 : # memberships.find_by(user_id: user.id)
Query(Membership)
.where("user_id = ?")
# Q 183 : # order("discussions.last_activity_at DESC")
Query(Discussion)
.order('id, last_activity_at')
# Q 184 : # order("lower(name)")
Query(User)
.order('id, name')
# Q 185 : # order(created_at: :asc)
Query(Stance)
.order('created_at')
# Q 186 : # order(created_at: :desc)
Query(Stance)
.order('created_at')
# Q 187 : # order(email_verified: :desc)
Query(User)
.order('email_verified')
# Q 188 : # poll.discussion.group
Query(FormalGroup)
.where("id = ?")
.where("id = ?")
# Q 189 : # poll.group
Query(FormalGroup)
.where("id = ?")
# Q 190 : # poll.group.add_member!(u)
Query(FormalGroup)
.where("id = ?")
# Q 191 : # poll.group.members_can_raise_motions
Query(FormalGroup)
.where("id = ?")
.select('members_can_raise_motions')
# Q 192 : # poll.group.members_can_vote
Query(FormalGroup)
.where("id = ?")
.select('members_can_vote')
# Q 193 : # poll.group.presence
Query(FormalGroup)
.where("id = ?")
# Q 194 : # poll.groups.any?(&:presence)
Query(Poll)

# Q 195 : # poll.guest_group.memberships.find_by(user: recipient)
Query(Poll)
.where("user = ?")
# Q 196 : # poll.guest_group.memberships.pluck(:token).include?(user.membership_token)
Query(Poll)
.select('token')
# Q 197 : # poll.poll_options.where(name: choice)
Query(PollOption)
.where("poll_id = ?")
.where("name = ?")
# Q 198 : # poll.poll_options.where(name: choice.keys).map
Query(PollOption)
.where("poll_id = ?")
.where("name = ?")
# Q 199 : # poll.stances.last.participant
Query(User)
.where("poll_id = ?")
.return_limit('1')
.where("id = ?")
# Q 200 : # poll.stances.latest.find_by(participant: recipient)
Query(Stance)
.where("poll_id = ?")
.select('latest')
.where("participant = ?")
# Q 201 : # poll_options.order(:priority).pluck(:name)
Query(PollOption)
.order('priority')
.select('name')
# Q 202 : # poll_options.where(name: @poll_option_removed_names).destroy_all
Query(PollOption)
.where("name = ?")
# Q 203 : # published.where(is_visible_to_public: false)
Query(FormalGroup)
.where("is_visible_to_public = ?")
# Q 204 : # published.where(is_visible_to_public: true)
Query(FormalGroup)
.where("is_visible_to_public = ?")
# Q 205 : # saml_provider.group
Query(Group)
.where("id = ?")
# Q 206 : # saml_provider.group.accepted_members.find_by(email: email)
Query(Group)
.where("id = ?")
.where("group_id = ?")
.where("email = ?")
# Q 207 : # select(:id, :key, :title, :result_group_name, :result_group_id, :description, :last_activity_at, :rank, "#{
# query}::text as query").select("ts_headline(discussions.description, plainto_tsquery(#{
# query}), 'ShortWord=0') as blurb").from(SearchVector.search_for(query, user, opts)).joins("INNER JOIN discussions on subquery.discussion_id = discussions.id").where("rank > 0").order("rank DESC, last_activity_at DESC")
Query(Discussion)
.select('? :? as query')
.select('ts_headline(discussions.description, plainto_tsquery(? ), 'ShortWord=0') as blurb')
.order('id, rank, last_activity_at')
# Q 208 : # self.class.select(:position).find(self.id).position
Query(Event)
.select('position')
.where("id = ?")
# Q 209 : # self.default_group_cover
Query(DefaultGroupCover)
.where("id = ?")
# Q 210 : # self.discussion.group_id
Query(Discussion)
.where("id = ?")
.select('group_id')
# Q 211 : # self.discussion.group_id
Query(Discussion)
.where("id = ?")
.select('group_id')
# Q 212 : # self.memberships.find_or_create_by!(user: user)
Query(Membership)
.where("group_id = ?")
# Q 213 : # self.poll_options.order(name: :asc)
Query(PollOption)
.where("poll_id = ?")
.order('name')
# Q 214 : # self.poll_options.order(priority: :asc)
Query(PollOption)
.where("poll_id = ?")
.order('priority')
# Q 215 : # self.stances.joins(:participant).joins(:stance_choices).where(:"stance_choices.poll_option_id" => self.poll_option_id).pluck(:"users.email").flatten.compact.uniq
Query(Stance)
.where("outcome_id = ?")
.joins('participant')
.joins('stance_choices')
.where("id != 0")
.distinct('')
# Q 216 : # stance_choices.find_by(poll_option_id: option.id)
Query(StanceChoice)
.where("poll_option_id = ?")
# Q 217 : # stance_choices.reasons_first.where("stance_choices.created_at > ?", since || 100.years.ago).includes(:poll_option, stance: :participant).where(:"stances.latest" => true).to_a.group_by(&:poll_option)
Query(StanceChoice)
.includes('poll_option')
# Q 218 : # tag.group.is_visible_to_parent_members?
Query(Group)
.where("id = ?")
# Q 219 : # tag.group.is_visible_to_public?
Query(Group)
.where("id = ?")
# Q 220 : # tag.group.members_can_edit_discussions?
Query(Group)
.where("id = ?")
# Q 221 : # user.ability.can?(:show, group.target_model)
Query(User)

# Q 222 : # user.drafts.find_by(draftable: draft_parent)
Query(User)
.where("draftable = ?")
# Q 223 : # user.identities.order(created_at: :desc)
Query(User)
.order('created_at')
# Q 224 : # user.identities.order(created_at: :desc)
Query(User)
.order('created_at')
# Q 225 : # user.notifications.includes(:actor).order(created_at: :desc).limit(limit)
Query(User)
.order('created_at')
.return_limit('')
# Q 226 : # users.pluck(:id)
Query(User)
.select('id')
# Q 227 : # where("accepted_at IS NOT NULL")
Query(InvitationAlreadyUsed)

# Q 228 : # where("archived_at IS NOT NULL")
Query(InvitationAlreadyUsed)

# Q 229 : # where("archived_at IS NOT NULL")
Query(Group)

# Q 230 : # where("archived_at is not null")
Query(Discussion)

# Q 231 : # where("closed_at IS NOT NULL")
Query(Poll)

# Q 232 : # where("closed_at IS NULL OR closed_at > ?", since)
Query(Poll)

# Q 233 : # where("deactivated_at IS NOT NULL")
Query(User)

# Q 234 : # where("last_activity_at > ?", time)
Query(Discussion)

# Q 235 : # where("reason IS NOT NULL OR reason != ''")
Query(Stance)

# Q 236 : # where("response IS NOT ?", nil).order("responded_at DESC")
Query(MembershipRequest)
.order('id, responded_at')
# Q 237 : # where(accepted_at: nil)
Query(InvitationAlreadyUsed)
.where("accepted_at = ?")
# Q 238 : # where(admin: true)
Query(InvitationAlreadyUsed)
.where("admin = ?")
# Q 239 : # where(archived_at: nil)
Query(InvitationAlreadyUsed)
.where("archived_at = ?")
# Q 240 : # where(archived_at: nil)
Query(Group)
.where("archived_at = ?")
# Q 241 : # where(author: user)
Query(Poll)
.where("author = ?")
# Q 242 : # where(closed_at: nil)
Query(Discussion)
.where("closed_at = ?")
# Q 243 : # where(closed_at: nil)
Query(Poll)
.where("closed_at = ?")
# Q 244 : # where(deactivated_at: nil)
Query(User)
.where("deactivated_at = ?")
# Q 245 : # where(email_verified: false)
Query(User)
.where("email_verified = ?")
# Q 246 : # where(email_verified: true)
Query(User)
.where("email_verified = ?")
# Q 247 : # where(group_id: group)
Query(InvitationAlreadyUsed)
.where("group_id = ?")
# Q 248 : # where(id: group.id_and_subgroup_ids)
Query(FormalGroup)
.where("id = ?")
# Q 249 : # where(is_admin: true)
Query(User)
.where("is_admin = ?")
# Q 250 : # where(kind: :announcement_created, eventable_type: "Group").within(since.beginning_of_hour, till.beginning_of_hour)
Query(Event)
.where("kind = ?")
.where("eventable_type = ?")
# Q 251 : # where(language: language)
Query(Translation)
.where("language = ?")
# Q 252 : # where(latest: true)
Query(Stance)
.where("latest = ?")
# Q 253 : # where(migrated_to_document: false)
Query(Attachment)
.where("migrated_to_document = ?")
# Q 254 : # where(parent_id: nil)
Query(FormalGroup)
.where("parent_id = ?")
# Q 255 : # where(private: false)
Query(Discussion)
.where("private = ?")
# Q 256 : # where(private: true)
Query(Discussion)
.where("private = ?")
# Q 257 : # where(response: nil).order("created_at DESC")
Query(MembershipRequest)
.where("response = ?")
.order('id, created_at')
# Q 258 : # where(used: false)
Query(LoginToken)
.where("used = ?")
# Q 259 : # where.not(closed_at: nil)
Query(Discussion)
.where("closed_at = ?")
# Q 260 : # where.not(kind: BLACKLISTED_KINDS)
Query(Event)
.where("kind = ?")
# Q 261 : # where.not(sequence_id: nil).order(sequence_id: :asc)
Query(Event)
.where("sequence_id = ?")
.order('sequence_id')
